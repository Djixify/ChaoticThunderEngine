#ifndef ENGINE_ENUMS
#define ENGINE_ENUMS
#include <glad\glad.h>

/// <summary>
/// Vertex Shaders: Approximately once per input vertex in the vertex stream. 
///     This may be less than once per vertex if indexed rendering is used, 
///     due to the Post Transform Cache, but it will be at least once for each 
///     unique set of vertex attributes.
/// Fragment Shaders: Once per Fragment generated by the rasterizer. It may be 
///     executed more than this, as "helper" fragment shader instances may be 
///     used by the implementation. These instances however cannot write data 
///     (in any way, whether fragment shader outputs, Image Load Store or anything 
///     else). They exist mostly to compute Implicit Derivatives to make many 
///     texture sampling functions work.
/// Geometry Shaders: Once per primitive reaching this stage. Geometry shader 
///     instancing allows the GS to be invoked multiple times for each input 
///     primitive.
/// Compute Shaders: The number of invocations is defined by the number of work 
///     groups requested by the dispatch operation multiplied by the compute 
///     shader's local size. Compute shader invocations within a work group have 
///     some limited intercommunication functionality.
/// Tessellation Control Shaders: Precisely once per output vertex per patch. 
///     Invocations operating on the same input patch can intercommunicate 
///     though their output variables.
/// Tessellation Evaluation Shaders: Approximately once per vertex in the 
///     tessellation of the abstract patch. A unique vertex in the patch may be 
///     processed more than once. The minimum number of TES invocations is once 
///     per unique vertex in the patch; the maximum is one for each vertex for 
///     each primitive generated by a patch.
/// </summary>
enum shader_type {
    VERTEX = GL_VERTEX_SHADER,
    FRAGMENT = GL_FRAGMENT_SHADER,
    GEOMETRY = GL_GEOMETRY_SHADER,
    COMPUTE = GL_COMPUTE_SHADER,
    TEST_CONTROL = GL_TESS_CONTROL_SHADER,
    TESS_EVALUATION = GL_TESS_EVALUATION_SHADER
};


/// <summary>
/// VERTEX_ARRAY_OBJECT: Buffer that stores pointers to the attributes, required
///     to be made before any other buffer
/// VERTEX_BUFFER_OBJECT: Buffer that stores the actual attribute data that the 
///     array object points to
/// ELEMENT_BUFFER_OBJECT: Connecting indices from the vertex buffer object to
///     form elements ex. 3 indices makes one triangle, indices may repeat 
///     multiple times, saving space
/// </summary>
enum buffer_type {
    VERTEX_ARRAY_OBJECT,
    VERTEX_BUFFER_OBJECT,
    ELEMENT_BUFFER_OBJECT
};

/// <summary>
/// GL_STREAM_DRAW: the data is set only once and used by the GPU at most a few times.
/// GL_STATIC_DRAW: the data is set only once and used many times.
/// GL_DYNAMIC_DRAW: the data is changed a lot and used many times.
/// </summary>
enum buffer_storage_type {
    STREAM = GL_STREAM_DRAW,
    STATIC = GL_STATIC_DRAW,
    DYNAMIC = GL_DYNAMIC_DRAW
};

enum class attribute_type {
    //Floating-point types. normalized​ must be GL_FALSE
    FLOAT16 = GL_HALF_FLOAT,
    FLOAT32 = GL_FLOAT,
    FLOAT64 = GL_DOUBLE,
    /*Integer types; these are converted to floats automatically. If normalized​ 
      is GL_TRUE, then the value will be converted to a float via integer 
      normalization (an unsigned byte value of 255 becomes 1.0f). If normalized​ 
      is GL_FALSE, it will be converted directly to a float as if by C-style 
      casting (255 becomes 255.0f, regardless of the size of the integer).*/
    INT8 = GL_BYTE,
    INT16 = GL_SHORT,
    INT32 = GL_INT,
    UINT8 = GL_UNSIGNED_BYTE,
    UINT16 = GL_UNSIGNED_SHORT,
    UINT32 = GL_UNSIGNED_INT
};

int AttributeSize(attribute_type attr);

#endif